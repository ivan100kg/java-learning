// Инкапсуляция. Наследование. Super, Protected.

// Encapsulation/Инкапсуляция
Getters-Setters
    Скрыть реализацию данных при необходимости можно с помощью private
    переменных и геттеров-сеттеров.
    Геттеры и сеттеры имеют доступ к закрытым переменным, проверяют какие-либо
    условия.
    private boolean clever;
    public boolean isClever() {
        return clever;
    }
    public void setClever(boolean clever) {
        this.clever = clever;
    }
    private StringBuilder name;
    public StringBuilder getName() {
        StringBuilder sb = new StringBuilder(name); // чтобы не было возможности
        return name;                                   изменить знач через get
    }
        public void setName(StringBuilder name) {
        this.name = name;
    }
   Если return type метода get это mutable тип данных(напр StringBuilder),
   то лучше возвращать его копию.

Inheritance/Наследование
    Родитель(Super/Parent/Base) может иметь множество детей.
    Дите(Child/extended/subclass/derived) может иметь только одного родителя!
    class Parent {}                 // родитель
    class Child extends Parent {}   // ребенок, extends - расширяет родителя

    Зачем нужно наследование.
    Короткое написание классов
    Легкость в изменении/добавлении новых классов.
    Exensibility (исп-е дочерних классов в функциях где ожидается родитель).
    Более легкое тестирование классов.
    Группировка классов под общим типом.

    Самый страрший родитель - Object
    class Parent extends java.lang.Object {}    // все наследуются по умолчанию

    Отношения между классами
    "Is-a" relationship
        class Animal{}
        class Mouse extends Animal{}
        // Mouse is Animal
    "Has-a" relationship
        class Window{}
        class House{
        Window w = new  Window();}
        // House has Window

    Что наследуется классом
    public
    default(без указания modif), если подкласс в том же пакете
    private не наследуются, но можно работать через getter-setter
    protected в том же пакете и во всех сабклассах
    Конструкторы не наследуются

    Кострукторы
    При создании объекта сабкласса, вызывается его конструктор, в конструкторе
    выз-ся метод super() который вызывает конструктор родителя ... так до
    класса Object, далее обратный ход, последним заканчивает работу констуктор
	сабкласса.
    super() - компилятор по дефолту добавляет в конструкторы.
    super(a,b) - можно вызывать определенные конструкторы родителя из 
    конструкторов наследников, для передачи параметров.
	Первая строка конструктора это:
		this()	// обращение к др конструктору своего класса
		super()	// обращение к конструктору родителя
	Вызываем сначала конструкторы своего класса, затем из базового конструктора
	(того в котором больше всех параметров и который все остальные конструкторы
	с нехваткой параметров вызывают с помощью this()) вызываем родительский
	конструктор(тот который подходит) с помощью super(). После констр-ра Object
	все вызовы возвращаются назад.
	



